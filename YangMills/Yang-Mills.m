(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];
Get["DiFfRG.m"]
$Assumptions=q>0&&k>0&&p>0&&Nc>0;


(* ::Input::Initialization:: *)
AddExtraVars[
k,
(*regulators*)
RA,RAdot,Rc,Rcdot,

(*Angles for symmetric points*)
cosp1,cosp2,cosp3,

(*strong couplings*)
ZA3,ZA4,ZAcbc,

(*momentum variables*)
p1,p2,p3,p4,

(*propagators*)
GA,GAInv,m2A
];


(* ::Input::Initialization:: *)
LitimRegulators:={
RB[k2_,q2_]->(k2-q2)HeavisideTheta[k2-q2],
RBdot[k2_,q2_]->2k2 HeavisideTheta[k2-q2]
}
ExponentialRegulators[b_]:={
RB[k2_,q2_]->k2 Exp[-(q2/k2)^b],
RBdot[k2_,q2_]->2 E^-(q2/k2)^b k2 (1+b (q2/k2)^b)
}
Sn[d_]:=(2 \[Pi]^(d/2))/Gamma[d/2]


(* ::Input::Initialization:: *)
DefineCombinedLorentzTensors[{
(*zero temperature*)
{
transProj[p,mu,nu],
deltaLorentz[mu,nu]-vec[p,mu]vec[p,nu]/sp[p,p]
},
{
transProj[p,q,mu,nu],
deltaLorentz[mu,nu]-vec[p,mu]vec[q,nu]/sp[p,q]
},
{
longProj[p,mu,nu],
vec[p,mu]vec[p,nu]/sp[p,p]
}
}];

DefineLorentzTensorIdentities[{
(*zero temperature*)
{transProj[p,mu,rho]transProj[p,rho,nu],transProj[p,mu,nu]},
{transProj[p,mu,rho]transProj[p,nu,rho],transProj[p,mu,nu]},
{transProj[p,rho,mu]transProj[p,rho,nu],transProj[p,mu,nu]},

{longProj[p,mu,rho]longProj[p,rho,nu],longProj[p,mu,nu]},
{longProj[p,mu,rho]longProj[p,nu,rho],longProj[p,mu,nu]},
{longProj[p,rho,mu]longProj[p,rho,nu],longProj[p,mu,nu]},

{transProj[p,mu,rho]longProj[p,rho,nu],0},
{transProj[p,rho,mu]longProj[p,rho,nu],0},
{transProj[p,mu,rho]longProj[p,nu,rho],0}
}];

ReplacementsLorentzTensors=Flatten[{
(*zero temperature*)
{transProj[p_,mu_,rho_]transProj[p_,rho_,nu_]:>transProj[p,mu,nu]},
{transProj[p_,mu_,rho_]transProj[p_,nu_,rho_]:>transProj[p,mu,nu]},
{transProj[p_,rho_,mu_]transProj[p_,rho_,nu_]:>transProj[p,mu,nu]},

{longProj[p_,mu_,rho_]longProj[p_,rho_,nu_]:>longProj[p,mu,nu]},
{longProj[p_,mu_,rho_]longProj[p_,nu_,rho_]:>longProj[p,mu,nu]},
{longProj[p_,rho_,mu_]longProj[p_,rho_,nu_]:>longProj[p,mu,nu]},

{transProj[p_,mu_,rho_]longProj[p_,rho_,nu_]:>0},
{transProj[p_,rho_,mu_]longProj[p_,rho_,nu_]:>0},
{transProj[p_,mu_,rho_]longProj[p_,nu_,rho_]:>0}
}];

InsertCombinedLorentzTensors[expr_]:=expr//.ReplacementsLorentzTensors//.{
transProj[p_,mu_,nu_]:>deltaLorentz[mu,nu]-vec[p,mu]vec[p,nu]/sp[p,p],
transProj[p_,q_,mu_,nu_]:>deltaLorentz[mu,nu]-vec[p,mu]vec[q,nu]/sp[p,q],
longProj[p_,mu_,nu_]:>vec[p,mu]vec[p,nu]/sp[p,p]
};


(* ::Input::Initialization:: *)
GlueTensors:={
PT[p_,v1_,a1_,v2_,a2_]:>transProj[p,v1,v2]deltaadjCol[a1,a2],
PL[p_,v1_,a1_,v2_,a2_]:>longProj[p,v1,v2]deltaadjCol[a1,a2],

(*Gluon Vertices*)
TAAA[p1_,v1_,a1_,p2_,v2_,a2_,p3_,v3_,a3_]:>I SUNFCol[a1,a2,a3] (deltaLorentz[v1,v2]vec[p2-p1,v3] +deltaLorentz[v1,v3] vec[p1-p3,v2] +deltaLorentz[v2,v3]vec[p3-p2,v1]),
TAAAA[p1_,v1_,a1_,p2_,v2_,a2_,p3_,v3_,a3_,p4_,v4_,a4_]:>(ff[a1,a2,a3,a4](deltaLorentz[v1,v3]deltaLorentz[v2,v4]-deltaLorentz[v1,v4]deltaLorentz[v2,v3])
											      +ff[a1,a3,a2,a4](deltaLorentz[v1,v2]deltaLorentz[v3,v4]-deltaLorentz[v1,v4]deltaLorentz[v2,v3])
											      +ff[a1,a4,a2,a3](deltaLorentz[v1,v2]deltaLorentz[v3,v4]-deltaLorentz[v1,v3]deltaLorentz[v2,v4])),
ff[ca_,cb_,cc_,cd_]:>Module[{i},SUNFCol[i,ca,cb]SUNFCol[i,cc,cd]],

(*Ghost-Gluon tensor structure*)
TAcbc[p1_,v1_,a1_,p2_,a2_,p3_,a3_]:>I  SUNFCol[a1,a2,a3] vec[p2,v1] 
};


PostTraceRulesGluons:={
RAdot[p2_]:>ZA[(k^nZA+1)^(1/nZA)]RBdot[k^2,p2]+dtZA[(k^nZA+1)^(1/nZA)]RB[k^2,p2],
RA[p2_]:>ZA[(k^nZA+1)^(1/nZA)]RB[k^2,p2],
GA[p2_]:>1/(m2A+ZA[Sqrt[p2]] p2+ZA[(k^nZA+1)^(1/nZA)]RB[k^2,p2]),
GAInv[p2_]:>ZA[Sqrt[p2]]p2+m2A,
nZA:>6
}


(* ::Input::Initialization:: *)
PreTraceRulesGluons={
(*Regulators*)
RAA[{p1_,v1_,a1_,p2_,v2_,a2_}]:>RA[sp[p2,p2]]deltaadjCol[a1,a2]transProj[p2,v1,v2](*+ RA[sp[p2,p2]]1/XiPL[p2,v1,a1,v2,a2]*),

(*Regulator Derivatives*)
RdotAA[{p1_,v1_,a1_,p2_,v2_,a2_}]:>RAdot[sp[p2,p2]]deltaadjCol[a1,a2]transProj[p2,v1,v2](*+ RAdot[sp[p2,p2]]1/XiPL[p2,v1,a1,v2,a2]*),

(*Propagators*)
\[CapitalGamma]AA[{p1_,v1_,a1_,p2_,v2_,a2_}] :> GAInv[sp[p2,p2]]deltaadjCol[a1,a2]transProj[p2,v1,v2](*+(1/Xi)PL[p2,v1,a1,v2,a2]*),
GAA[{p1_,v1_,a1_,p2_,v2_,a2_}] :>GA[sp[p1,p1]]deltaadjCol[a1,a2]transProj[p1,v1,v2](*+Xi PL[p1,v1,a1,v2,a2]*),
(*Pure gauge Vertices*)
\[CapitalGamma]AAA[{p1_,v1_,a1_,p2_,v2_,a2_,p3_,v3_,a3_}] :>ZA3[\[Sqrt](1/3 (sp[p1,p1]+sp[p2,p2]+sp[p3,p3]))]TAAA[p1,v1,a1,p2,v2,a2,p3,v3,a3],
\[CapitalGamma]AAAA[{p1_,v1_,a1_,p2_,v2_,a2_,p3_,v3_,a3_,p4_,v4_,a4_}] :>ZA4[\[Sqrt](1/4 (sp[p1,p1]+sp[p2,p2]+sp[p3,p3]+sp[p4,p4]))] TAAAA[p1,v1,a1,p2,v2,a2,p3,v3,a3,p4,v4,a4],

(*Ghost-Gluon Vertices*)
\[CapitalGamma]Acbc[{p1_,v1_,a1_,p2_,a2_,p3_,a3_}] :>ZAcbc[\[Sqrt](1/3 (sp[p1,p1]+sp[p2,p2]+sp[p3,p3]))] TAcbc[p1,v1,a1,p2,a2,p3,a3]
};

(*Must be 3(Nc^2-1)*)
FormTrace[(\[CapitalGamma]AA[{p,v1,a1,-p,v2,a2}]+RAA[{p,v1,a1,-p,v2,a2}]) GAA[{-p,v2,a2,p1,v1,a1}]//.PreTraceRulesGluons//.GlueTensors]//.PostTraceRulesGluons//Simplify


PostTraceRulesGhosts:={
Rc[p2_]:>RB[k^2,p2],
Rcdot[p2_]:>RBdot[k^2,p2]- RB[k^2,p2]etac[Sqrt[p2]]
}


(* ::Input::Initialization:: *)
PreTraceRulesGhosts:={
(*Regulators*)
Rcbc[{p1_,a1_,p2_,a2_}]:>deltaadjCol[a1,a2] Rc[sp[p2,p2]],

(*Regulator Derivatives*)
Rdotcbc[{p1_,a1_,p2_,a2_}]:>deltaadjCol[a1,a2] Rcdot[sp[p2,p2]],

(*Propagators*)
\[CapitalGamma]cbc[{p1_,a1_,p2_,a2_}]:>-deltaadjCol[a1,a2]   sp[p2,p2],
Gccb[{p1_,a1_,p2_,a2_}]:>deltaadjCol[a1,a2]/(sp[p1,p1]+Rc[sp[p1,p1]])
}

(*Must be 1-Nc^2*)
FormTrace[(\[CapitalGamma]cbc[{-q,a1,q,a2}]-Rcbc[{-q,a1,q,a2}])Gccb[{q,a2,-q,a1}]//.PreTraceRulesGhosts]//.PostTraceRulesGhosts//Simplify


(* ::Input::Initialization:: *)
PreTraceRules:=PreTraceRulesGluons\[Union]PreTraceRulesGhosts\[Union]GlueTensors
PostTraceRules:=PostTraceRulesGhosts\[Union]PostTraceRulesGluons


(* ::Input::Initialization:: *)
fRGEq = {
"Prefactor"->{1/2},
<|"type"->"Regulatordot", "indices"->{i,j}|>,
<|"type"->"Propagator", "indices"->{i,j}|>
};

fields = <|"bosonic"-> { A[p,{v, c}]},
                 "fermionic"->{{cb[p,{c}],c[p,{c}]}}|>;

Truncation = {
{A,A},{cb,c},(* propagators *)
{cb,c,A},{A,A,A},{A,A,A,A}(* glue sector scatterings *)
};

SetupfRG = <|"MasterEquation"->fRGEq,
"FieldSpace"->fields,
"Truncation"->Truncation|>;


couplingsList:={
ZA3[__], ZA4[__], ZAcbc[__]
};
YMSimp[expr_]:=Collect[expr,couplingsList,Simplify];
SetStandardSimplify[YMSimp];


(*Diagrams*)
DerivativeListAA= {A[-p,{v1,a1}],A[p,{v2,a2}]};
DiagramsAA =  AutoSaveRestore["diagrams/AA",DeriveFunctionalEquation[SetupfRG,DerivativeListAA,"OutputLevel"->"FullDiagrams"]];
Print["DiagramsAA got "<>ToString[Length[DiagramsAA]]<>" diagrams."]


(*Projection*)
Normm2A=PT[p,v1,a1,v2,a2]PT[p,v1,a1,v2,a2]//.PreTraceRules//FormTrace;
Projectorm2A=PT[p,v1,a1,v2,a2]/ Normm2A ;
(*Sanity Check*)
sanity=simplifyMomenta4D[q,p,(Projectorm2A \[CapitalGamma]AA[{-p,v2,a2,p,v1,a1}]//.PreTraceRules//FormTrace//expandScalarProducts4D)]//.p->0//.PostTraceRules//Simplify;
Print["Projection check is ", sanity, ", should be m2A"]


Projectionm2A=(Projectorm2A DiagramsAA)//.PreTraceRules//InsertCombinedLorentzTensors;
m2ALoop=1/2 Integrate[TracePropagator4D[8,"m2A",Projectionm2A,q,p]//.p->0,{cos1,-1,1}]//.PostTraceRules//Simplify


(*Projection*)
NormZA=PT[p,v1,a1,v2,a2]PT[p,v1,a1,v2,a2]//.PreTraceRules//FormTrace;
ProjectorZA=PT[p,v1,a1,v2,a2]/ NormZA ;
(*Sanity Check*)
sanity=(ProjectorZA (\[CapitalGamma]AA[{-p,v2,a2,p,v1,a1}]-\[CapitalGamma]AA[{-q,v2,a2,q,v1,a1}])/sp[p,p]//.PreTraceRules//FormTrace//expandScalarProducts4D)//.{cos[p,q]->1,q->0}//.PostTraceRules//Simplify;
Print["Projection check is ", sanity, ", should be ZA[p]\[InvisibleSpace]"]


ProjectionZA=(ProjectorZA DiagramsAA)//.PreTraceRules;
ZALoop=TracePropagator4D[4,"ZA",ProjectionZA,q,p];
ZALoop=Simplify[(ZALoop-(ZALoop//.p->0))/p^2]//.PostTraceRules


PlotDiagrams[SetupfRG,{A[a],A[b]},{"AA"->Orange,"ccb"->Dotted}]


(*Diagrams*)
DerivativeListcbc= {cb[-p,{a1}],c[p,{a2}]};
Diagramscbc =  AutoSaveRestore["diagrams/cbc", DeriveFunctionalEquation[SetupfRG,DerivativeListcbc,"OutputLevel"->"FullDiagrams"]];
Print["Diagramscbc got "<>ToString[Length[Diagramscbc]]<>" diagrams."]


(*Projection*)
Normetac=deltaadjCol[a2,a1]  deltaadjCol[a1,a2]  //.PreTraceRules//FormTrace;
Projectoretac=-(-deltaadjCol[a2,a1]/ Normetac );
(*Sanity Check*)
sanity=(Projectoretac \[CapitalGamma]cbc[{-p,a1,p,a2}]/sp[p,p]//.PreTraceRules//FormTrace//expandScalarProducts4D)//.PostTraceRules//Simplify;
Print["Projection check is ", sanity, ", should be -1"]


Projectionetac=(Projectoretac Diagramscbc/sp[p,p])//.PreTraceRules;
etacLoop=TracePropagator4D[8,"etac",Projectionetac,q,p]//.PostTraceRules


Clear[a,b,c,d]
PlotDiagrams[SetupfRG,{cb[a],c[b]},{"AA"->Orange,"ccb"->Dotted,"cc"->Dotted,"cbcb"->Dotted}]


(*Diagrams*)
DerivativeListA3= {A[p1,{v1,a1}],A[p2,{v2,a2}],A[p3,{v3,a3}]};
DiagramsA3=  AutoSaveRestore["diagrams/A3", DeriveFunctionalEquation[SetupfRG,DerivativeListA3,"OutputLevel"->"FullDiagrams"]];
Print["DiagramsAAA got "<>ToString[Length[DiagramsA3]]<>" diagrams."]
DiagramsA3=ProjectDiagramsToSymmetricPoint[DiagramsA3,SetupfRG,q,p1,p2,p3];
Print["DiagramsA3 reduces to "<>ToString[Length[DiagramsA3]]<>" diagrams on symmetric point."];


(*Projection*)
NormZA3=(TAAA[p1,v1i,a1i,p2,v2i,a2i,p3,v3i,a3i]PT[p1,v1,a1,v1i,a1i]PT[p2,v2i,a2i,v2,a2]PT[p3,v3i,a3i,v3,a3]
TAAA[p1,v1,a1,p2,v2,a2,p3,v3,a3])//.PreTraceRules//FormTrace//Simplify;
ProjectorZA3=TAAA[p1,v1i,a1i,p2,v2i,a2i,p3,v3i,a3i]/NormZA3  PT[p1,v1,a1i,v1i,a1]PT[p2,v2i,a2i,v2,a2]PT[p3,v3i,a3i,v3,a3]//.PreTraceRules//Simplify;
(*Sanity check*)
sanity=Simplify[ProjectorZA3 \[CapitalGamma]AAA[{p1,v1,a1,p2,v2,a2,p3,v3,a3}]//.PreTraceRules//FormTrace]//.{p1->p,p2->p,p3->p}//.PostTraceRules//expandScalarProducts4D//Simplify;
Print["Projection check is ", sanity, ", should be ZA3[p]"]


ProjectionZA3=(ProjectorZA3 DiagramsA3)//.PreTraceRules//InsertCombinedLorentzTensors;
ZA3LoopSP=TraceToSP4D[8,"ZA3",ProjectionZA3,q,p,p1,p2,p3]//.PostTraceRules


PlotDiagrams[SetupfRG,{A[a],A[b],A[c]},{"AA"->Orange,"ccb"->Dotted,"cc"->Dotted,"cbcb"->Dotted}]


(*Diagrams*)
DerivativeListAcbc={ A[p3,{v3,a3}],cb[p2,{a2}],c[p1,{a1}]};
DiagramsAcbc =  AutoSaveRestore["diagrams/Acbc", DeriveFunctionalEquation[SetupfRG,DerivativeListAcbc,"OutputLevel"->"FullDiagrams"]];
Print["DiagramsAcbc got "<>ToString[Length[DiagramsAcbc]]<>" diagrams."]
DiagramsAcbc=ProjectDiagramsToSymmetricPoint[DiagramsAcbc,SetupfRG,q,p1,p2,p3];
Print["DiagramsAcbc reduces to "<>ToString[Length[DiagramsAcbc]]<>" diagrams on symmetric point."];


(*Projection*)
NormZAcbc=Simplify[TAcbc[p3,v3i,a3i,p1,a1,p2,a2]PT[p3,v3i,a3i,v3,a3]TAcbc[p3,v3,a3,p2,a2,p1,a1]//.PreTraceRules//FormTrace];
ProjectorZAcbc=(TAcbc[p3,v3i,a3i,p1,a1,p2,a2]PT[p3,v3i,a3i,v3,a3])/NormZAcbc;
(*Sanity check*)
sanity=Simplify[ProjectorZAcbc \[CapitalGamma]Acbc[{p3,v3,a3,p2,a2,p1,a1}]//.PreTraceRules//FormTrace]//.{p1->p,p2->p,p3->p}//.PostTraceRules//expandScalarProducts4D//FullSimplify;
Print["Projection check is ", sanity, ", should be ZAcbc[p]"]


ProjectionAcbc=(ProjectorZAcbc DiagramsAcbc)//.PreTraceRules//InsertCombinedLorentzTensors;
ZAcbcSPLoop=TraceToSP4D[8,"ZAcbc",ProjectionAcbc,q,p,p1,p2,p3]//.PostTraceRules
ZAcbcRenorm=etac[p]ZAcbc[p]


Clear[a,b,c,d]
PlotDiagrams[SetupfRG,{A[a],cb[b],c[d]},{"AA"->Orange,"ccb"->Dotted,"cc"->Dotted,"cbcb"->Dotted}]


(*Diagrams*)
DerivativeListA4= {A[p1,{v1,a1}],A[p2,{v2,a2}],A[p3,{v3,a3}],A[p4,{v4,a4}]};
DiagramsA4=AutoSaveRestore["diagrams/A4", DeriveFunctionalEquation[SetupfRG,DerivativeListA4,"OutputLevel"->"FullDiagrams"]];
Print["DiagramsA4 got "<>ToString[Length[DiagramsA4]]<>" diagrams."]
DiagramsA4=ProjectDiagramsToSymmetricPoint[DiagramsA4,SetupfRG,q,p1,p2,p3,p4];
Print["DiagramsA4 reduces to "<>ToString[Length[DiagramsA4]]<>" diagrams on symmetric point."];


NormZA4=((TAAAA[p1,v1i,a1i,p2,v2i,a2i,p3,v3i,a3i,p4,v4i,a4i]PT[p1,v1,a1i,v1i,a1]PT[p2,v2i,a2i,v2,a2]PT[p3,v3i,a3i,v3,a3]PT[p4,v4i,a4i,v4,a4]//.PreTraceRules)TAAAA[p1,v1,a1,p2,v2,a2,p3,v3,a3,p4,v4,a4])//.PreTraceRules//InsertCombinedLorentzTensors//FormTrace//Simplify;
ProjectorZA4=1/NormZA4  TAAAA[p1,v1i,a1i,p2,v2i,a2i,p3,v3i,a3i,p4,v4i,a4i]PT[p1,v1,a1i,v1i,a1]PT[p2,v2i,a2i,v2,a2]PT[p3,v3i,a3i,v3,a3]PT[p4,v4i,a4i,v4,a4]//.PreTraceRules//Factor;
(*Sanity check*)
sanity=Simplify[ProjectorZA4  \[CapitalGamma]AAAA[{p1,v1,a1,p2,v2,a2,p3,v3,a3,p4,v4,a4}]//.PreTraceRules//InsertCombinedLorentzTensors//FormTrace]//.{p1->p,p2->p,p3->p,p4->p}//.PostTraceRules//expandScalarProducts4D//Simplify;
Print["Projection check is ", sanity, ", should be \[InvisibleSpace]ZA4[p]"]


ProjectionZA4=(ProjectorZA4 DiagramsA4)//.PreTraceRules//InsertCombinedLorentzTensors;
ZA4LoopSP=TraceToSP4D[1,"ZA4",ProjectionZA4,q,p,p1,p2,p3,p4]//.PostTraceRules


PlotDiagrams[SetupfRG,{A[a],A[b],A[c],A[d]},{"AA"->Orange,"ccb"->Dotted,"cc"->Dotted,"cbcb"->Dotted}]
